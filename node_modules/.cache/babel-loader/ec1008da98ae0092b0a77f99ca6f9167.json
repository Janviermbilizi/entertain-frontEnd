{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/admin/Desktop/entertain-me/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/admin/Desktop/entertain-me/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar xml2js = require('xml2js');\n\nvar url = require('url');\n\nvar fields = require('./fields');\n\nvar utils = require('./utils');\n\nvar DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml'\n};\nvar DEFAULT_MAX_REDIRECTS = 5;\nvar DEFAULT_TIMEOUT = 60000;\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Parser);\n\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  _createClass(Parser, [{\n    key: \"parseString\",\n    value: function parseString(xml, callback) {\n      var _this = this;\n\n      var prom = new Promise(function (resolve, reject) {\n        _this.xmlParser.parseString(xml, function (err, result) {\n          if (err) return reject(err);\n\n          if (!result) {\n            return reject(new Error('Unable to parse XML.'));\n          }\n\n          var feed = null;\n\n          if (result.feed) {\n            feed = _this.buildAtomFeed(result);\n          } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n            feed = _this.buildRSS2(result);\n          } else if (result['rdf:RDF']) {\n            feed = _this.buildRSS1(result);\n          } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n            feed = _this.buildRSS0_9(result);\n          } else if (result.rss && _this.options.defaultRSS) {\n            switch (_this.options.defaultRSS) {\n              case 0.9:\n                feed = _this.buildRSS0_9(result);\n                break;\n\n              case 1:\n                feed = _this.buildRSS1(result);\n                break;\n\n              case 2:\n                feed = _this.buildRSS2(result);\n                break;\n\n              default:\n                return reject(new Error(\"default RSS version not recognized.\"));\n            }\n          } else {\n            return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"));\n          }\n\n          resolve(feed);\n        });\n      });\n      prom = utils.maybePromisify(callback, prom);\n      return prom;\n    }\n  }, {\n    key: \"parseURL\",\n    value: function parseURL(feedUrl, callback) {\n      var _this2 = this;\n\n      var redirectCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var xml = '';\n      var get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n      var urlParts = url.parse(feedUrl);\n      var headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n      var timeout = null;\n      var prom = new Promise(function (resolve, reject) {\n        var requestOpts = Object.assign({\n          headers: headers\n        }, urlParts, _this2.options.requestOptions);\n        var req = get(requestOpts, function (res) {\n          if (_this2.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n            if (redirectCount === _this2.options.maxRedirects) {\n              return reject(new Error(\"Too many redirects\"));\n            } else {\n              var newLocation = url.resolve(feedUrl, res.headers['location']);\n              return _this2.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n            }\n          } else if (res.statusCode >= 300) {\n            return reject(new Error(\"Status code \" + res.statusCode));\n          }\n\n          var encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n          res.setEncoding(encoding);\n          res.on('data', function (chunk) {\n            xml += chunk;\n          });\n          res.on('end', function () {\n            return _this2.parseString(xml).then(resolve, reject);\n          });\n        });\n        req.on('error', reject);\n        timeout = setTimeout(function () {\n          return reject(new Error(\"Request timed out after \" + _this2.options.timeout + \"ms\"));\n        }, _this2.options.timeout);\n      }).then(function (data) {\n        clearTimeout(timeout);\n        return Promise.resolve(data);\n      }, function (e) {\n        clearTimeout(timeout);\n        return Promise.reject(e);\n      });\n      prom = utils.maybePromisify(callback, prom);\n      return prom;\n    }\n  }, {\n    key: \"buildAtomFeed\",\n    value: function buildAtomFeed(xmlObj) {\n      var _this3 = this;\n\n      var feed = {\n        items: []\n      };\n      utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n\n      if (xmlObj.feed.link) {\n        feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n        feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n      }\n\n      if (xmlObj.feed.title) {\n        var title = xmlObj.feed.title[0] || '';\n        if (title._) title = title._;\n        if (title) feed.title = title;\n      }\n\n      if (xmlObj.feed.updated) {\n        feed.lastBuildDate = xmlObj.feed.updated[0];\n      }\n\n      (xmlObj.feed.entry || []).forEach(function (entry) {\n        var item = {};\n        utils.copyFromXML(entry, item, _this3.options.customFields.item);\n\n        if (entry.title) {\n          var _title = entry.title[0] || '';\n\n          if (_title._) _title = _title._;\n          if (_title) item.title = _title;\n        }\n\n        if (entry.link && entry.link.length) {\n          item.link = utils.getLink(entry.link, 'alternate', 0);\n        }\n\n        if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n        if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n        if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n\n        if (entry.content && entry.content.length) {\n          item.content = utils.getContent(entry.content[0]);\n          item.contentSnippet = utils.getSnippet(item.content);\n        }\n\n        if (entry.id) {\n          item.id = entry.id[0];\n        }\n\n        _this3.setISODate(item);\n\n        feed.items.push(item);\n      });\n      return feed;\n    }\n  }, {\n    key: \"buildRSS0_9\",\n    value: function buildRSS0_9(xmlObj) {\n      var channel = xmlObj.rss.channel[0];\n      var items = channel.item;\n      return this.buildRSS(channel, items);\n    }\n  }, {\n    key: \"buildRSS1\",\n    value: function buildRSS1(xmlObj) {\n      xmlObj = xmlObj['rdf:RDF'];\n      var channel = xmlObj.channel[0];\n      var items = xmlObj.item;\n      return this.buildRSS(channel, items);\n    }\n  }, {\n    key: \"buildRSS2\",\n    value: function buildRSS2(xmlObj) {\n      var channel = xmlObj.rss.channel[0];\n      var items = channel.item;\n      var feed = this.buildRSS(channel, items);\n\n      if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n        this.decorateItunes(feed, channel);\n      }\n\n      return feed;\n    }\n  }, {\n    key: \"buildRSS\",\n    value: function buildRSS(channel, items) {\n      var _this4 = this;\n\n      items = items || [];\n      var feed = {\n        items: []\n      };\n      var feedFields = fields.feed.concat(this.options.customFields.feed);\n      var itemFields = fields.item.concat(this.options.customFields.item);\n\n      if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n        feed.feedUrl = channel['atom:link'][0].$.href;\n      }\n\n      if (channel.image && channel.image[0] && channel.image[0].url) {\n        feed.image = {};\n        var image = channel.image[0];\n        if (image.link) feed.image.link = image.link[0];\n        if (image.url) feed.image.url = image.url[0];\n        if (image.title) feed.image.title = image.title[0];\n        if (image.width) feed.image.width = image.width[0];\n        if (image.height) feed.image.height = image.height[0];\n      }\n\n      utils.copyFromXML(channel, feed, feedFields);\n      items.forEach(function (xmlItem) {\n        var item = {};\n        utils.copyFromXML(xmlItem, item, itemFields);\n\n        if (xmlItem.enclosure) {\n          item.enclosure = xmlItem.enclosure[0].$;\n        }\n\n        if (xmlItem.description) {\n          item.content = utils.getContent(xmlItem.description[0]);\n          item.contentSnippet = utils.getSnippet(item.content);\n        }\n\n        if (xmlItem.guid) {\n          item.guid = xmlItem.guid[0];\n          if (item.guid._) item.guid = item.guid._;\n        }\n\n        if (xmlItem.category) item.categories = xmlItem.category;\n\n        _this4.setISODate(item);\n\n        feed.items.push(item);\n      });\n      return feed;\n    }\n    /**\n     * Add iTunes specific fields from XML to extracted JSON\n     *\n     * @access public\n     * @param {object} feed extracted\n     * @param {object} channel parsed XML\n     */\n\n  }, {\n    key: \"decorateItunes\",\n    value: function decorateItunes(feed, channel) {\n      var items = channel.item || [];\n      var categories = [];\n      feed.itunes = {};\n\n      if (channel['itunes:owner']) {\n        var owner = {};\n\n        if (channel['itunes:owner'][0]['itunes:name']) {\n          owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n        }\n\n        if (channel['itunes:owner'][0]['itunes:email']) {\n          owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n        }\n\n        feed.itunes.owner = owner;\n      }\n\n      if (channel['itunes:image']) {\n        var image;\n        var hasImageHref = channel['itunes:image'][0] && channel['itunes:image'][0].$ && channel['itunes:image'][0].$.href;\n        image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n\n        if (image) {\n          feed.itunes.image = image;\n        }\n      }\n\n      if (channel['itunes:category']) {\n        channel['itunes:category'].forEach(function (category) {\n          categories.push(category.$.text);\n        });\n        feed.itunes.categories = categories;\n      }\n\n      if (channel['itunes:keywords']) {\n        if (channel['itunes:keywords'].length > 1) {\n          feed.itunes.keywords = channel['itunes:keywords'].map(function (keyword) {\n            return keyword.$.text;\n          });\n        } else {\n          var keywords = channel['itunes:keywords'][0];\n\n          if (keywords && typeof keywords._ === 'string') {\n            keywords = keywords._;\n          }\n\n          if (keywords) feed.itunes.keywords = keywords.split(',');\n        }\n      }\n\n      utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n      items.forEach(function (item, index) {\n        var entry = feed.items[index];\n        entry.itunes = {};\n        utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n        var image = item['itunes:image'];\n\n        if (image && image[0] && image[0].$ && image[0].$.href) {\n          entry.itunes.image = image[0].$.href;\n        }\n      });\n    }\n  }, {\n    key: \"setISODate\",\n    value: function setISODate(item) {\n      var date = item.pubDate || item.date;\n\n      if (date) {\n        try {\n          item.isoDate = new Date(date.trim()).toISOString();\n        } catch (e) {// Ignore bad date format\n        }\n      }\n    }\n  }]);\n\n  return Parser;\n}();\n\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}